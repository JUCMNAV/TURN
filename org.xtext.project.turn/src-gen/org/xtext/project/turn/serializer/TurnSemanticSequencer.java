/*
 * generated by Xtext 2.12.0
 */
package org.xtext.project.turn.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;
import org.xtext.project.turn.services.TurnGrammarAccess;
import org.xtext.project.turn.turn.Actor;
import org.xtext.project.turn.turn.AndFork;
import org.xtext.project.turn.turn.AndJoin;
import org.xtext.project.turn.turn.ArtificialRule;
import org.xtext.project.turn.turn.BoundElement;
import org.xtext.project.turn.turn.ComponentBinding;
import org.xtext.project.turn.turn.ComponentRef;
import org.xtext.project.turn.turn.Concern;
import org.xtext.project.turn.turn.ConcreteCondition;
import org.xtext.project.turn.turn.ConcreteStrategy;
import org.xtext.project.turn.turn.ConcreteURNspec;
import org.xtext.project.turn.turn.Condition;
import org.xtext.project.turn.turn.Connect;
import org.xtext.project.turn.turn.Contribution;
import org.xtext.project.turn.turn.ContributionChange;
import org.xtext.project.turn.turn.ContributionContext;
import org.xtext.project.turn.turn.ContributionContextGroup;
import org.xtext.project.turn.turn.Decomposition;
import org.xtext.project.turn.turn.Dependency;
import org.xtext.project.turn.turn.EndPoint;
import org.xtext.project.turn.turn.EndpointWithConnect;
import org.xtext.project.turn.turn.Evaluation;
import org.xtext.project.turn.turn.EvaluationStrategy;
import org.xtext.project.turn.turn.FailureLabel;
import org.xtext.project.turn.turn.FailurePoint;
import org.xtext.project.turn.turn.InBinding;
import org.xtext.project.turn.turn.IndicatorEvaluation;
import org.xtext.project.turn.turn.IntentionalElement;
import org.xtext.project.turn.turn.LinearConversion;
import org.xtext.project.turn.turn.LongBoundElement;
import org.xtext.project.turn.turn.LongName;
import org.xtext.project.turn.turn.Metadata;
import org.xtext.project.turn.turn.OrBody;
import org.xtext.project.turn.turn.OrFork;
import org.xtext.project.turn.turn.OrJoin;
import org.xtext.project.turn.turn.OutBinding;
import org.xtext.project.turn.turn.Path;
import org.xtext.project.turn.turn.PathBodyNodes;
import org.xtext.project.turn.turn.PluginBinding;
import org.xtext.project.turn.turn.QualToQMapping;
import org.xtext.project.turn.turn.QualToQMappings;
import org.xtext.project.turn.turn.RegularOrFork;
import org.xtext.project.turn.turn.RespRef;
import org.xtext.project.turn.turn.StartPoint;
import org.xtext.project.turn.turn.StrategiesGroup;
import org.xtext.project.turn.turn.Stub;
import org.xtext.project.turn.turn.StubDeclaration;
import org.xtext.project.turn.turn.StubOutPath;
import org.xtext.project.turn.turn.StubParameters;
import org.xtext.project.turn.turn.Text;
import org.xtext.project.turn.turn.Timer;
import org.xtext.project.turn.turn.TurnPackage;
import org.xtext.project.turn.turn.UCMmap;
import org.xtext.project.turn.turn.URNlink;
import org.xtext.project.turn.turn.URNspec;
import org.xtext.project.turn.turn.WaitingPlace;

@SuppressWarnings("all")
public class TurnSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private TurnGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TurnPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TurnPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case TurnPackage.AND_FORK:
				sequence_AndFork(context, (AndFork) semanticObject); 
				return; 
			case TurnPackage.AND_JOIN:
				sequence_AndJoin(context, (AndJoin) semanticObject); 
				return; 
			case TurnPackage.ARTIFICIAL_RULE:
				sequence_ArtificialRule(context, (ArtificialRule) semanticObject); 
				return; 
			case TurnPackage.BOUND_ELEMENT:
				sequence_BoundElement(context, (BoundElement) semanticObject); 
				return; 
			case TurnPackage.COMPONENT_BINDING:
				sequence_ComponentBinding(context, (ComponentBinding) semanticObject); 
				return; 
			case TurnPackage.COMPONENT_REF:
				sequence_ComponentRef(context, (ComponentRef) semanticObject); 
				return; 
			case TurnPackage.CONCERN:
				sequence_Concern(context, (Concern) semanticObject); 
				return; 
			case TurnPackage.CONCRETE_CONDITION:
				sequence_ConcreteCondition(context, (ConcreteCondition) semanticObject); 
				return; 
			case TurnPackage.CONCRETE_STRATEGY:
				sequence_ConcreteStrategy(context, (ConcreteStrategy) semanticObject); 
				return; 
			case TurnPackage.CONCRETE_UR_NSPEC:
				sequence_ConcreteURNspec(context, (ConcreteURNspec) semanticObject); 
				return; 
			case TurnPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case TurnPackage.CONNECT:
				sequence_Connect(context, (Connect) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION:
				sequence_Contribution(context, (Contribution) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION_CHANGE:
				sequence_ContributionChange(context, (ContributionChange) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION_CONTEXT:
				sequence_ContributionContext(context, (ContributionContext) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION_CONTEXT_GROUP:
				sequence_ContributionContextGroup(context, (ContributionContextGroup) semanticObject); 
				return; 
			case TurnPackage.DECOMPOSITION:
				sequence_Decomposition(context, (Decomposition) semanticObject); 
				return; 
			case TurnPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case TurnPackage.END_POINT:
				sequence_EndPoint(context, (EndPoint) semanticObject); 
				return; 
			case TurnPackage.ENDPOINT_WITH_CONNECT:
				sequence_EndpointWithConnect(context, (EndpointWithConnect) semanticObject); 
				return; 
			case TurnPackage.EVALUATION:
				sequence_Evaluation(context, (Evaluation) semanticObject); 
				return; 
			case TurnPackage.EVALUATION_STRATEGY:
				sequence_EvaluationStrategy(context, (EvaluationStrategy) semanticObject); 
				return; 
			case TurnPackage.FAILURE_LABEL:
				sequence_FailureLabel(context, (FailureLabel) semanticObject); 
				return; 
			case TurnPackage.FAILURE_POINT:
				sequence_FailurePoint(context, (FailurePoint) semanticObject); 
				return; 
			case TurnPackage.IN_BINDING:
				sequence_InBinding(context, (InBinding) semanticObject); 
				return; 
			case TurnPackage.INDICATOR_EVALUATION:
				sequence_IndicatorEvaluation(context, (IndicatorEvaluation) semanticObject); 
				return; 
			case TurnPackage.INTENTIONAL_ELEMENT:
				sequence_IntentionalElement(context, (IntentionalElement) semanticObject); 
				return; 
			case TurnPackage.LINEAR_CONVERSION:
				sequence_LinearConversion(context, (LinearConversion) semanticObject); 
				return; 
			case TurnPackage.LONG_BOUND_ELEMENT:
				sequence_LongBoundElement(context, (LongBoundElement) semanticObject); 
				return; 
			case TurnPackage.LONG_NAME:
				sequence_LongName(context, (LongName) semanticObject); 
				return; 
			case TurnPackage.METADATA:
				sequence_Metadata(context, (Metadata) semanticObject); 
				return; 
			case TurnPackage.OR_BODY:
				if (rule == grammarAccess.getOrBodyRule()
						|| rule == grammarAccess.getElseOrForkBodyRule()) {
					sequence_ElseOrForkBody_OrForkBody(context, (OrBody) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrForkBodyRule()) {
					sequence_OrForkBody(context, (OrBody) semanticObject); 
					return; 
				}
				else break;
			case TurnPackage.OR_FORK:
				sequence_OrFork(context, (OrFork) semanticObject); 
				return; 
			case TurnPackage.OR_JOIN:
				sequence_OrJoin(context, (OrJoin) semanticObject); 
				return; 
			case TurnPackage.OUT_BINDING:
				sequence_OutBinding(context, (OutBinding) semanticObject); 
				return; 
			case TurnPackage.PATH:
				sequence_Path(context, (Path) semanticObject); 
				return; 
			case TurnPackage.PATH_BODY_NODES:
				if (rule == grammarAccess.getPathBodyNodesRule()) {
					sequence_PathBodyNodes(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPathWithReferencedEndRule()) {
					sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPathBodyRule()
						|| rule == grammarAccess.getPathWithRegularEndRule()) {
					sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub_PathWithRegularEnd(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPathWithReferencedStubRule()) {
					sequence_PathBodyNodes_PathWithReferencedStub(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else break;
			case TurnPackage.PLUGIN_BINDING:
				sequence_PluginBinding(context, (PluginBinding) semanticObject); 
				return; 
			case TurnPackage.QUAL_TO_QMAPPING:
				sequence_QualToQMapping(context, (QualToQMapping) semanticObject); 
				return; 
			case TurnPackage.QUAL_TO_QMAPPINGS:
				sequence_QualToQMappings(context, (QualToQMappings) semanticObject); 
				return; 
			case TurnPackage.REGULAR_OR_FORK:
				sequence_RegularOrFork(context, (RegularOrFork) semanticObject); 
				return; 
			case TurnPackage.RESP_REF:
				sequence_RespRef(context, (RespRef) semanticObject); 
				return; 
			case TurnPackage.START_POINT:
				sequence_StartPoint(context, (StartPoint) semanticObject); 
				return; 
			case TurnPackage.STRATEGIES_GROUP:
				sequence_StrategiesGroup(context, (StrategiesGroup) semanticObject); 
				return; 
			case TurnPackage.STUB:
				sequence_Stub(context, (Stub) semanticObject); 
				return; 
			case TurnPackage.STUB_DECLARATION:
				sequence_StubDeclaration(context, (StubDeclaration) semanticObject); 
				return; 
			case TurnPackage.STUB_OUT_PATH:
				sequence_StubOutPath(context, (StubOutPath) semanticObject); 
				return; 
			case TurnPackage.STUB_PARAMETERS:
				sequence_StubParameters(context, (StubParameters) semanticObject); 
				return; 
			case TurnPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case TurnPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			case TurnPackage.UC_MMAP:
				sequence_UCMmap(context, (UCMmap) semanticObject); 
				return; 
			case TurnPackage.UR_NLINK:
				sequence_URNlink(context, (URNlink) semanticObject); 
				return; 
			case TurnPackage.UR_NSPEC:
				sequence_URNspec(context, (URNspec) semanticObject); 
				return; 
			case TurnPackage.WAITING_PLACE:
				sequence_WaitingPlace(context, (WaitingPlace) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XbasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXBlockExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXLiteralRule()
						|| rule == grammarAccess.getXClosureRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Actor
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName (importance=ImportanceType | importanceQuantitative=QuantitativeValue)? elems+=IntentionalElement*)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns AndFork
	 *     RegularEnd returns AndFork
	 *     AndFork returns AndFork
	 *     ReferencedBoundElement returns AndFork
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? pathbody+=PathBody* connectingAndBody=PathBody?)
	 */
	protected void sequence_AndFork(ISerializationContext context, AndFork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns AndJoin
	 *     PathBodyNode returns AndJoin
	 *     ReferencedEnd returns AndJoin
	 *     AndJoin returns AndJoin
	 *     ReferencedBoundElement returns AndJoin
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName)
	 */
	protected void sequence_AndJoin(ISerializationContext context, AndJoin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.AND_JOIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.AND_JOIN__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.AND_JOIN__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.AND_JOIN__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndJoinAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAndJoinAccess().getLongNameLongNameParserRuleCall_2_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ArtificialRule
	 *     ArtificialRule returns ArtificialRule
	 *
	 * Constraint:
	 *     longName=STRING
	 */
	protected void sequence_ArtificialRule(ISerializationContext context, ArtificialRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.ARTIFICIAL_RULE__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.ARTIFICIAL_RULE__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArtificialRuleAccess().getLongNameSTRINGTerminalRuleCall_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoundOption returns BoundElement
	 *     BoundElement returns BoundElement
	 *
	 * Constraint:
	 *     elem=[ReferencedBoundElement|QualifiedName]
	 */
	protected void sequence_BoundElement(ISerializationContext context, BoundElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.BOUND_ELEMENT__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.BOUND_ELEMENT__ELEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundElementAccess().getElemReferencedBoundElementQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(TurnPackage.Literals.BOUND_ELEMENT__ELEM, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns ComponentBinding
	 *     ComponentBinding returns ComponentBinding
	 *
	 * Constraint:
	 *     (componentIn=[ComponentRef|QualifiedName] componentOut=[ComponentRef|QualifiedName])
	 */
	protected void sequence_ComponentBinding(ISerializationContext context, ComponentBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_IN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_IN));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentBindingAccess().getComponentInComponentRefQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_IN, false));
		feeder.accept(grammarAccess.getComponentBindingAccess().getComponentOutComponentRefQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_OUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ComponentRef
	 *     ComponentRef returns ComponentRef
	 *     ReferencedBoundElement returns ComponentRef
	 *
	 * Constraint:
	 *     (protected?='protected'? kind=COMPONENTKIND? name=QualifiedName longName=LongName (element=BoundOption elements+=BoundOption*)?)
	 */
	protected void sequence_ComponentRef(ISerializationContext context, ComponentRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concern returns Concern
	 *     URNmodelElement returns Concern
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName condition=Condition? element=[URNmodelElement|ID] elements+=[URNmodelElement|ID]*)
	 */
	protected void sequence_Concern(ISerializationContext context, Concern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConcreteCondition returns ConcreteCondition
	 *
	 * Constraint:
	 *     (label=STRING description=STRING)
	 */
	protected void sequence_ConcreteCondition(ISerializationContext context, ConcreteCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__LABEL));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcreteConditionAccess().getLabelSTRINGTerminalRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getConcreteConditionAccess().getDescriptionSTRINGTerminalRuleCall_1_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConcreteStrategy returns ConcreteStrategy
	 *
	 * Constraint:
	 *     author=STRING
	 */
	protected void sequence_ConcreteStrategy(ISerializationContext context, ConcreteStrategy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_STRATEGY__AUTHOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_STRATEGY__AUTHOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcreteStrategyAccess().getAuthorSTRINGTerminalRuleCall_1_0(), semanticObject.getAuthor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConcreteURNspec returns ConcreteURNspec
	 *
	 * Constraint:
	 *     (
	 *         description=STRING 
	 *         author=STRING 
	 *         created=STRING 
	 *         modified=STRING 
	 *         specVersion=STRING 
	 *         urnVersion=STRING
	 *     )
	 */
	protected void sequence_ConcreteURNspec(ISerializationContext context, ConcreteURNspec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__DESCRIPTION));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__AUTHOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__AUTHOR));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__CREATED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__CREATED));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__MODIFIED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__MODIFIED));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__SPEC_VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__SPEC_VERSION));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__URN_VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__URN_VERSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getAuthorSTRINGTerminalRuleCall_4_0(), semanticObject.getAuthor());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getCreatedSTRINGTerminalRuleCall_6_0(), semanticObject.getCreated());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getModifiedSTRINGTerminalRuleCall_8_0(), semanticObject.getModified());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getSpecVersionSTRINGTerminalRuleCall_10_0(), semanticObject.getSpecVersion());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getUrnVersionSTRINGTerminalRuleCall_12_0(), semanticObject.getUrnVersion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (expression=Text info=ConcreteCondition?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathBodyNode returns Connect
	 *     Connect returns Connect
	 *     ReferencedBoundElement returns Connect
	 *
	 * Constraint:
	 *     connectsTo=[ConnectElement|QualifiedName]
	 */
	protected void sequence_Connect(ISerializationContext context, Connect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONNECT__CONNECTS_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONNECT__CONNECTS_TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectAccess().getConnectsToConnectElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(TurnPackage.Literals.CONNECT__CONNECTS_TO, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContributionChange returns ContributionChange
	 *
	 * Constraint:
	 *     (contribution=[Contribution|QualifiedName] (newContribution=ContributionType | newQuantitativeContribution=QuantitativeValue))
	 */
	protected void sequence_ContributionChange(ISerializationContext context, ContributionChange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ContributionContextGroup
	 *     ContributionContextGroup returns ContributionContextGroup
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName contrib=[ContributionContext|ID] contribs+=[ContributionContext|ID]*)
	 */
	protected void sequence_ContributionContextGroup(ISerializationContext context, ContributionContextGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ContributionContext
	 *     ContributionContext returns ContributionContext
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         changes+=ContributionChange* 
	 *         (includedContext=[ContributionContext|ID] includedContexts+=[ContributionContext|ID]*)?
	 *     )
	 */
	protected void sequence_ContributionContext(ISerializationContext context, ContributionContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Contribution
	 *     ElementLink returns Contribution
	 *     Contribution returns Contribution
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName longName=LongName)? 
	 *         dest=[IntentionalElement|QualifiedName] 
	 *         correlation?='correlated'? 
	 *         (contribution=ContributionType | quantitativeContribution=QuantitativeValue)
	 *     )
	 */
	protected void sequence_Contribution(ISerializationContext context, Contribution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Decomposition
	 *     ElementLink returns Decomposition
	 *     Decomposition returns Decomposition
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? decompositionType=DecompositionType dest=[IntentionalElement|QualifiedName])
	 */
	protected void sequence_Decomposition(ISerializationContext context, Decomposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Dependency
	 *     ElementLink returns Dependency
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? dest=[IntentionalElement|QualifiedName])
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrBody returns OrBody
	 *     ElseOrForkBody returns OrBody
	 *
	 * Constraint:
	 *     (regularBody+=RegularOrFork+ elseBody=PathBody?)
	 */
	protected void sequence_ElseOrForkBody_OrForkBody(ISerializationContext context, OrBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EndPoint returns EndPoint
	 *     ReferencedBoundElement returns EndPoint
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName condition=Condition) | condition=Condition)?
	 */
	protected void sequence_EndPoint(ISerializationContext context, EndPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegularEnd returns EndpointWithConnect
	 *     EndpointWithConnect returns EndpointWithConnect
	 *     ReferencedBoundElement returns EndpointWithConnect
	 *
	 * Constraint:
	 *     (regularEnd=EndPoint connect=Connect?)
	 */
	protected void sequence_EndpointWithConnect(ISerializationContext context, EndpointWithConnect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns EvaluationStrategy
	 *     EvaluationStrategy returns EvaluationStrategy
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         info=ConcreteStrategy? 
	 *         evaluations+=Evaluation* 
	 *         (includedStrategy=[EvaluationStrategy|ID] includedStrategies+=[EvaluationStrategy|ID]*)?
	 *     )
	 */
	protected void sequence_EvaluationStrategy(ISerializationContext context, EvaluationStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns Evaluation
	 *
	 * Constraint:
	 *     (
	 *         intElement=[IntentionalElement|QualifiedName] 
	 *         exceeds?='exceeding'? 
	 *         (qualitativeEvaluation=QualitativeLabel | evaluation=QuantitativeValue | (indicatorEval=IndicatorEvaluation conversion=[IndicatorConversion|ID]))
	 *     )
	 */
	protected void sequence_Evaluation(ISerializationContext context, Evaluation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FailureLabel returns FailureLabel
	 *
	 * Constraint:
	 *     failure=STRING
	 */
	protected void sequence_FailureLabel(ISerializationContext context, FailureLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.FAILURE_LABEL__FAILURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.FAILURE_LABEL__FAILURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFailureLabelAccess().getFailureSTRINGTerminalRuleCall_1_0(), semanticObject.getFailure());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns FailurePoint
	 *     PathBodyNode returns FailurePoint
	 *     ReferencedEnd returns FailurePoint
	 *     FailurePoint returns FailurePoint
	 *     ReferencedBoundElement returns FailurePoint
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? ((condition=Condition failLabel=FailureLabel) | (failLabel=FailureLabel condition=Condition))?)
	 */
	protected void sequence_FailurePoint(ISerializationContext context, FailurePoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns InBinding
	 *     InBinding returns InBinding
	 *
	 * Constraint:
	 *     (mapStart=[StartPoint|QualifiedName] index=PositiveInteger)
	 */
	protected void sequence_InBinding(ISerializationContext context, InBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.IN_BINDING__MAP_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.IN_BINDING__MAP_START));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.IN_BINDING__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.IN_BINDING__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInBindingAccess().getMapStartStartPointQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(TurnPackage.Literals.IN_BINDING__MAP_START, false));
		feeder.accept(grammarAccess.getInBindingAccess().getIndexPositiveIntegerParserRuleCall_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IndicatorEvaluation returns IndicatorEvaluation
	 *
	 * Constraint:
	 *     (realWorldLabel=STRING | realWorldValue=INT)
	 */
	protected void sequence_IndicatorEvaluation(ISerializationContext context, IndicatorEvaluation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns IntentionalElement
	 *     IntentionalElement returns IntentionalElement
	 *
	 * Constraint:
	 *     (
	 *         type=IntentionalElementType 
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         (importance=ImportanceType | importanceQuantitative=QuantitativeValue)? 
	 *         unit=STRING? 
	 *         linksSrc+=ElementLink*
	 *     )
	 */
	protected void sequence_IntentionalElement(ISerializationContext context, IntentionalElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns LinearConversion
	 *     IndicatorConversion returns LinearConversion
	 *     LinearConversion returns LinearConversion
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         unit=STRING 
	 *         targetValue=INT 
	 *         thresholdValue=INT 
	 *         worstValue=INT
	 *     )
	 */
	protected void sequence_LinearConversion(ISerializationContext context, LinearConversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__LONG_NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__UNIT));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__TARGET_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__TARGET_VALUE));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__THRESHOLD_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__THRESHOLD_VALUE));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__WORST_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__WORST_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinearConversionAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLinearConversionAccess().getLongNameLongNameParserRuleCall_2_0(), semanticObject.getLongName());
		feeder.accept(grammarAccess.getLinearConversionAccess().getUnitSTRINGTerminalRuleCall_5_0(), semanticObject.getUnit());
		feeder.accept(grammarAccess.getLinearConversionAccess().getTargetValueINTTerminalRuleCall_7_0(), semanticObject.getTargetValue());
		feeder.accept(grammarAccess.getLinearConversionAccess().getThresholdValueINTTerminalRuleCall_9_0(), semanticObject.getThresholdValue());
		feeder.accept(grammarAccess.getLinearConversionAccess().getWorstValueINTTerminalRuleCall_11_0(), semanticObject.getWorstValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoundOption returns LongBoundElement
	 *     LongBoundElement returns LongBoundElement
	 *
	 * Constraint:
	 *     (from=QualifiedName to=QualifiedName)
	 */
	protected void sequence_LongBoundElement(ISerializationContext context, LongBoundElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__FROM));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLongBoundElementAccess().getFromQualifiedNameParserRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getLongBoundElementAccess().getToQualifiedNameParserRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LongName returns LongName
	 *
	 * Constraint:
	 *     (longname=ID | longname=STRING)?
	 */
	protected void sequence_LongName(ISerializationContext context, LongName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metadata returns Metadata
	 *
	 * Constraint:
	 *     (elem=[URNmodelElement|QualifiedName]? name=ID value=Text)
	 */
	protected void sequence_Metadata(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrForkBody returns OrBody
	 *
	 * Constraint:
	 *     regularBody+=RegularOrFork+
	 */
	protected void sequence_OrForkBody(ISerializationContext context, OrBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns OrFork
	 *     RegularEnd returns OrFork
	 *     OrFork returns OrFork
	 *     ReferencedBoundElement returns OrFork
	 *
	 * Constraint:
	 *     ((((name=QualifiedName longName=LongName)? body=OrBody) | condition=Condition) connectingOrBody=PathBody?)
	 */
	protected void sequence_OrFork(ISerializationContext context, OrFork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns OrJoin
	 *     PathBodyNode returns OrJoin
	 *     ReferencedEnd returns OrJoin
	 *     OrJoin returns OrJoin
	 *     ReferencedBoundElement returns OrJoin
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName)
	 */
	protected void sequence_OrJoin(ISerializationContext context, OrJoin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OR_JOIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OR_JOIN__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OR_JOIN__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OR_JOIN__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrJoinAccess().getNameQualifiedNameParserRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOrJoinAccess().getLongNameLongNameParserRuleCall_2_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns OutBinding
	 *     OutBinding returns OutBinding
	 *
	 * Constraint:
	 *     (mapEnd=[EndPoint|QualifiedName] index=PositiveInteger)
	 */
	protected void sequence_OutBinding(ISerializationContext context, OutBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OUT_BINDING__MAP_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OUT_BINDING__MAP_END));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OUT_BINDING__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OUT_BINDING__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutBindingAccess().getMapEndEndPointQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(TurnPackage.Literals.OUT_BINDING__MAP_END, false));
		feeder.accept(grammarAccess.getOutBindingAccess().getIndexPositiveIntegerParserRuleCall_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathBodyNodes returns PathBodyNodes
	 *
	 * Constraint:
	 *     pathNodes+=PathBodyNode*
	 */
	protected void sequence_PathBodyNodes(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathWithReferencedEnd returns PathBodyNodes
	 *
	 * Constraint:
	 *     (pathNodes+=PathBodyNode* (referencedStub=[Stub|QualifiedName] index=PositiveInteger)? referencedEnd=[ReferencedEnd|ID]?)
	 */
	protected void sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathBody returns PathBodyNodes
	 *     PathWithRegularEnd returns PathBodyNodes
	 *
	 * Constraint:
	 *     (pathNodes+=PathBodyNode* (referencedStub=[Stub|QualifiedName] index=PositiveInteger)? referencedEnd=[ReferencedEnd|ID]? pathEnd=RegularEnd?)
	 */
	protected void sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub_PathWithRegularEnd(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathWithReferencedStub returns PathBodyNodes
	 *
	 * Constraint:
	 *     (pathNodes+=PathBodyNode* (referencedStub=[Stub|QualifiedName] index=PositiveInteger)?)
	 */
	protected void sequence_PathBodyNodes_PathWithReferencedStub(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path returns Path
	 *
	 * Constraint:
	 *     (startPoint=StartPoint pathBody=PathBody)
	 */
	protected void sequence_Path(ISerializationContext context, Path semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.PATH__START_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.PATH__START_POINT));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.PATH__PATH_BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.PATH__PATH_BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathAccess().getStartPointStartPointParserRuleCall_0_0(), semanticObject.getStartPoint());
		feeder.accept(grammarAccess.getPathAccess().getPathBodyPathBodyParserRuleCall_1_0(), semanticObject.getPathBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PluginBinding returns PluginBinding
	 *
	 * Constraint:
	 *     (condition=Condition? replication=PositiveInteger? map=[UCMmap|ID] (binding=Binding bindings+=Binding*)?)
	 */
	protected void sequence_PluginBinding(ISerializationContext context, PluginBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualToQMapping returns QualToQMapping
	 *
	 * Constraint:
	 *     (exceeds?='exceeding'? realWorldLabel=STRING (qualitativeEvaluation=QualitativeLabel | evaluation=QuantitativeValue))
	 */
	protected void sequence_QualToQMapping(ISerializationContext context, QualToQMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns QualToQMappings
	 *     IndicatorConversion returns QualToQMappings
	 *     QualToQMappings returns QualToQMappings
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName unit=STRING mappings+=QualToQMapping+)
	 */
	protected void sequence_QualToQMappings(ISerializationContext context, QualToQMappings semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegularOrFork returns RegularOrFork
	 *
	 * Constraint:
	 *     (condition=Condition pathBody=PathBody)
	 */
	protected void sequence_RegularOrFork(ISerializationContext context, RegularOrFork semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__CONDITION));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__PATH_BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__PATH_BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegularOrForkAccess().getConditionConditionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getRegularOrForkAccess().getPathBodyPathBodyParserRuleCall_1_0(), semanticObject.getPathBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns RespRef
	 *     PathBodyNode returns RespRef
	 *     ReferencedEnd returns RespRef
	 *     RespRef returns RespRef
	 *     ReferencedBoundElement returns RespRef
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName)
	 */
	protected void sequence_RespRef(ISerializationContext context, RespRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.RESP_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.RESP_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.RESP_REF__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.RESP_REF__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRespRefAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRespRefAccess().getLongNameLongNameParserRuleCall_2_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns StartPoint
	 *     StartPoint returns StartPoint
	 *     ConnectElement returns StartPoint
	 *     ReferencedBoundElement returns StartPoint
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName longName=LongName precondition=Condition) | 
	 *         precondition=Condition | 
	 *         (failKind=FailureKind name=QualifiedName longName=LongName catches=STRING?)
	 *     )?
	 */
	protected void sequence_StartPoint(ISerializationContext context, StartPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns StrategiesGroup
	 *     StrategiesGroup returns StrategiesGroup
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName evalStrategy=[EvaluationStrategy|ID] evalStrategies+=[EvaluationStrategy|ID]*)
	 */
	protected void sequence_StrategiesGroup(ISerializationContext context, StrategiesGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StubDeclaration returns StubDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName params=StubParameters)
	 */
	protected void sequence_StubDeclaration(ISerializationContext context, StubDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.STUB_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.STUB_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.STUB_DECLARATION__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.STUB_DECLARATION__LONG_NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.STUB_DECLARATION__PARAMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.STUB_DECLARATION__PARAMS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStubDeclarationAccess().getNameQualifiedNameParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStubDeclarationAccess().getLongNameLongNameParserRuleCall_1_0(), semanticObject.getLongName());
		feeder.accept(grammarAccess.getStubDeclarationAccess().getParamsStubParametersParserRuleCall_3_0(), semanticObject.getParams());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StubOutPath returns StubOutPath
	 *
	 * Constraint:
	 *     (index=PositiveInteger threshold=PositiveInteger? path=PathBody)
	 */
	protected void sequence_StubOutPath(ISerializationContext context, StubOutPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StubParameters returns StubParameters
	 *
	 * Constraint:
	 *     plugin+=PluginBinding*
	 */
	protected void sequence_StubParameters(ISerializationContext context, StubParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Stub
	 *     RegularEnd returns Stub
	 *     Stub returns Stub
	 *     ReferencedBoundElement returns Stub
	 *
	 * Constraint:
	 *     (
	 *         stubType=StubType? 
	 *         index=PositiveInteger? 
	 *         (((name=QualifiedName longName=LongName)? params=StubParameters) | stubRef=[StubDeclaration|QualifiedName]) 
	 *         outPaths+=StubOutPath* 
	 *         connectingStubBody=PathBody?
	 *     )
	 */
	protected void sequence_Stub(ISerializationContext context, Stub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Text returns Text
	 *
	 * Constraint:
	 *     content+=TextContent+
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Timer
	 *     PathBodyNode returns Timer
	 *     Timer returns Timer
	 *     ConnectElement returns Timer
	 *     ReferencedBoundElement returns Timer
	 *
	 * Constraint:
	 *     (kind=WAITKIND? (name=QualifiedName longName=LongName)? timeoutCondition=Condition? timeoutPath=PathBody? condition=Condition?)
	 */
	protected void sequence_Timer(ISerializationContext context, Timer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns UCMmap
	 *     UCMmap returns UCMmap
	 *
	 * Constraint:
	 *     (
	 *         singleton?='singleton'? 
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         stubs+=StubDeclaration* 
	 *         paths+=Path* 
	 *         components+=ComponentRef*
	 *     )
	 */
	protected void sequence_UCMmap(ISerializationContext context, UCMmap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNlink returns URNlink
	 *     URNmodelElement returns URNlink
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? type=Text? fromElem=[URNmodelElement|ID] toElem=[URNmodelElement|ID])
	 */
	protected void sequence_URNlink(ISerializationContext context, URNlink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNspec returns URNspec
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName info=ConcreteURNspec?) | 
	 *         actors+=Actor | 
	 *         showAsMeansEnd?='showAsMeansEnd' | 
	 *         stratGroups+=StrategiesGroup | 
	 *         strategies+=EvaluationStrategy | 
	 *         indConversions+=IndicatorConversion | 
	 *         contribContextGroups+=ContributionContextGroup | 
	 *         contribContexts+=ContributionContext | 
	 *         ucmMaps+=UCMmap | 
	 *         concerns+=Concern | 
	 *         urnlinks+=URNlink | 
	 *         metadata+=Metadata
	 *     )+
	 */
	protected void sequence_URNspec(ISerializationContext context, URNspec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns WaitingPlace
	 *     PathBodyNode returns WaitingPlace
	 *     WaitingPlace returns WaitingPlace
	 *     ConnectElement returns WaitingPlace
	 *     ReferencedBoundElement returns WaitingPlace
	 *
	 * Constraint:
	 *     (kind=WAITKIND? (name=QualifiedName longName=LongName)? condition=Condition?)
	 */
	protected void sequence_WaitingPlace(ISerializationContext context, WaitingPlace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
