/*
 * generated by Xtext 2.16.0-SNAPSHOT
 */
package org.xtext.project.turn.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.project.turn.services.TurnGrammarAccess;
import org.xtext.project.turn.turn.Actor;
import org.xtext.project.turn.turn.AndFork;
import org.xtext.project.turn.turn.AndJoin;
import org.xtext.project.turn.turn.ArtificialRule;
import org.xtext.project.turn.turn.BoundElement;
import org.xtext.project.turn.turn.ComponentBinding;
import org.xtext.project.turn.turn.ComponentRef;
import org.xtext.project.turn.turn.Concern;
import org.xtext.project.turn.turn.ConcreteCondition;
import org.xtext.project.turn.turn.ConcreteStrategy;
import org.xtext.project.turn.turn.ConcreteURNspec;
import org.xtext.project.turn.turn.Condition;
import org.xtext.project.turn.turn.Connect;
import org.xtext.project.turn.turn.Contribution;
import org.xtext.project.turn.turn.ContributionChange;
import org.xtext.project.turn.turn.ContributionContext;
import org.xtext.project.turn.turn.ContributionContextGroup;
import org.xtext.project.turn.turn.Decomposition;
import org.xtext.project.turn.turn.Dependency;
import org.xtext.project.turn.turn.EndPoint;
import org.xtext.project.turn.turn.EndpointWithConnect;
import org.xtext.project.turn.turn.Evaluation;
import org.xtext.project.turn.turn.EvaluationStrategy;
import org.xtext.project.turn.turn.FailureLabel;
import org.xtext.project.turn.turn.FailurePoint;
import org.xtext.project.turn.turn.InBinding;
import org.xtext.project.turn.turn.IndicatorEvaluation;
import org.xtext.project.turn.turn.IntentionalElement;
import org.xtext.project.turn.turn.LinearConversion;
import org.xtext.project.turn.turn.LongBoundElement;
import org.xtext.project.turn.turn.LongName;
import org.xtext.project.turn.turn.Metadata;
import org.xtext.project.turn.turn.OrBody;
import org.xtext.project.turn.turn.OrFork;
import org.xtext.project.turn.turn.OrJoin;
import org.xtext.project.turn.turn.OutBinding;
import org.xtext.project.turn.turn.Path;
import org.xtext.project.turn.turn.PathBodyNodes;
import org.xtext.project.turn.turn.PluginBinding;
import org.xtext.project.turn.turn.QualToQMapping;
import org.xtext.project.turn.turn.QualToQMappings;
import org.xtext.project.turn.turn.RegularOrFork;
import org.xtext.project.turn.turn.RespRef;
import org.xtext.project.turn.turn.StartPoint;
import org.xtext.project.turn.turn.StrategiesGroup;
import org.xtext.project.turn.turn.Stub;
import org.xtext.project.turn.turn.StubDeclaration;
import org.xtext.project.turn.turn.StubOutPath;
import org.xtext.project.turn.turn.StubParameters;
import org.xtext.project.turn.turn.Text;
import org.xtext.project.turn.turn.Timer;
import org.xtext.project.turn.turn.TurnPackage;
import org.xtext.project.turn.turn.UCMmap;
import org.xtext.project.turn.turn.URNlink;
import org.xtext.project.turn.turn.URNspec;
import org.xtext.project.turn.turn.WaitingPlace;

@SuppressWarnings("all")
public class TurnSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TurnGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TurnPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TurnPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case TurnPackage.AND_FORK:
				sequence_AndFork(context, (AndFork) semanticObject); 
				return; 
			case TurnPackage.AND_JOIN:
				sequence_AndJoin(context, (AndJoin) semanticObject); 
				return; 
			case TurnPackage.ARTIFICIAL_RULE:
				sequence_ArtificialRule(context, (ArtificialRule) semanticObject); 
				return; 
			case TurnPackage.BOUND_ELEMENT:
				sequence_BoundElement(context, (BoundElement) semanticObject); 
				return; 
			case TurnPackage.COMPONENT_BINDING:
				sequence_ComponentBinding(context, (ComponentBinding) semanticObject); 
				return; 
			case TurnPackage.COMPONENT_REF:
				sequence_ComponentRef(context, (ComponentRef) semanticObject); 
				return; 
			case TurnPackage.CONCERN:
				sequence_Concern(context, (Concern) semanticObject); 
				return; 
			case TurnPackage.CONCRETE_CONDITION:
				sequence_ConcreteCondition(context, (ConcreteCondition) semanticObject); 
				return; 
			case TurnPackage.CONCRETE_STRATEGY:
				sequence_ConcreteStrategy(context, (ConcreteStrategy) semanticObject); 
				return; 
			case TurnPackage.CONCRETE_UR_NSPEC:
				sequence_ConcreteURNspec(context, (ConcreteURNspec) semanticObject); 
				return; 
			case TurnPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case TurnPackage.CONNECT:
				sequence_Connect(context, (Connect) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION:
				sequence_Contribution(context, (Contribution) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION_CHANGE:
				sequence_ContributionChange(context, (ContributionChange) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION_CONTEXT:
				sequence_ContributionContext(context, (ContributionContext) semanticObject); 
				return; 
			case TurnPackage.CONTRIBUTION_CONTEXT_GROUP:
				sequence_ContributionContextGroup(context, (ContributionContextGroup) semanticObject); 
				return; 
			case TurnPackage.DECOMPOSITION:
				sequence_Decomposition(context, (Decomposition) semanticObject); 
				return; 
			case TurnPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case TurnPackage.END_POINT:
				sequence_EndPoint(context, (EndPoint) semanticObject); 
				return; 
			case TurnPackage.ENDPOINT_WITH_CONNECT:
				sequence_EndpointWithConnect(context, (EndpointWithConnect) semanticObject); 
				return; 
			case TurnPackage.EVALUATION:
				sequence_Evaluation(context, (Evaluation) semanticObject); 
				return; 
			case TurnPackage.EVALUATION_STRATEGY:
				sequence_EvaluationStrategy(context, (EvaluationStrategy) semanticObject); 
				return; 
			case TurnPackage.FAILURE_LABEL:
				sequence_FailureLabel(context, (FailureLabel) semanticObject); 
				return; 
			case TurnPackage.FAILURE_POINT:
				sequence_FailurePoint(context, (FailurePoint) semanticObject); 
				return; 
			case TurnPackage.IN_BINDING:
				sequence_InBinding(context, (InBinding) semanticObject); 
				return; 
			case TurnPackage.INDICATOR_EVALUATION:
				sequence_IndicatorEvaluation(context, (IndicatorEvaluation) semanticObject); 
				return; 
			case TurnPackage.INTENTIONAL_ELEMENT:
				sequence_IntentionalElement(context, (IntentionalElement) semanticObject); 
				return; 
			case TurnPackage.LINEAR_CONVERSION:
				sequence_LinearConversion(context, (LinearConversion) semanticObject); 
				return; 
			case TurnPackage.LONG_BOUND_ELEMENT:
				sequence_LongBoundElement(context, (LongBoundElement) semanticObject); 
				return; 
			case TurnPackage.LONG_NAME:
				sequence_LongName(context, (LongName) semanticObject); 
				return; 
			case TurnPackage.METADATA:
				sequence_Metadata(context, (Metadata) semanticObject); 
				return; 
			case TurnPackage.OR_BODY:
				if (rule == grammarAccess.getOrBodyRule()
						|| rule == grammarAccess.getElseOrForkBodyRule()) {
					sequence_ElseOrForkBody_OrForkBody(context, (OrBody) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrForkBodyRule()) {
					sequence_OrForkBody(context, (OrBody) semanticObject); 
					return; 
				}
				else break;
			case TurnPackage.OR_FORK:
				sequence_OrFork(context, (OrFork) semanticObject); 
				return; 
			case TurnPackage.OR_JOIN:
				sequence_OrJoin(context, (OrJoin) semanticObject); 
				return; 
			case TurnPackage.OUT_BINDING:
				sequence_OutBinding(context, (OutBinding) semanticObject); 
				return; 
			case TurnPackage.PATH:
				sequence_Path(context, (Path) semanticObject); 
				return; 
			case TurnPackage.PATH_BODY_NODES:
				if (rule == grammarAccess.getPathBodyNodesRule()) {
					sequence_PathBodyNodes(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPathWithReferencedEndRule()) {
					sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPathBodyRule()
						|| rule == grammarAccess.getPathWithRegularEndRule()) {
					sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub_PathWithRegularEnd(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPathWithReferencedStubRule()) {
					sequence_PathBodyNodes_PathWithReferencedStub(context, (PathBodyNodes) semanticObject); 
					return; 
				}
				else break;
			case TurnPackage.PLUGIN_BINDING:
				sequence_PluginBinding(context, (PluginBinding) semanticObject); 
				return; 
			case TurnPackage.QUAL_TO_QMAPPING:
				sequence_QualToQMapping(context, (QualToQMapping) semanticObject); 
				return; 
			case TurnPackage.QUAL_TO_QMAPPINGS:
				sequence_QualToQMappings(context, (QualToQMappings) semanticObject); 
				return; 
			case TurnPackage.REGULAR_OR_FORK:
				sequence_RegularOrFork(context, (RegularOrFork) semanticObject); 
				return; 
			case TurnPackage.RESP_REF:
				sequence_RespRef(context, (RespRef) semanticObject); 
				return; 
			case TurnPackage.START_POINT:
				sequence_StartPoint(context, (StartPoint) semanticObject); 
				return; 
			case TurnPackage.STRATEGIES_GROUP:
				sequence_StrategiesGroup(context, (StrategiesGroup) semanticObject); 
				return; 
			case TurnPackage.STUB:
				sequence_Stub(context, (Stub) semanticObject); 
				return; 
			case TurnPackage.STUB_DECLARATION:
				sequence_StubDeclaration(context, (StubDeclaration) semanticObject); 
				return; 
			case TurnPackage.STUB_OUT_PATH:
				sequence_StubOutPath(context, (StubOutPath) semanticObject); 
				return; 
			case TurnPackage.STUB_PARAMETERS:
				sequence_StubParameters(context, (StubParameters) semanticObject); 
				return; 
			case TurnPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case TurnPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			case TurnPackage.UC_MMAP:
				sequence_UCMmap(context, (UCMmap) semanticObject); 
				return; 
			case TurnPackage.UR_NLINK:
				sequence_URNlink(context, (URNlink) semanticObject); 
				return; 
			case TurnPackage.UR_NSPEC:
				sequence_URNspec(context, (URNspec) semanticObject); 
				return; 
			case TurnPackage.WAITING_PLACE:
				sequence_WaitingPlace(context, (WaitingPlace) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Actor
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName (importance=ImportanceType | importanceQuantitative=QuantitativeValue)? elems+=IntentionalElement*)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns AndFork
	 *     RegularEnd returns AndFork
	 *     AndFork returns AndFork
	 *     ReferencedBoundElement returns AndFork
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? pathbody+=PathBody* connectingAndBody=PathBody?)
	 */
	protected void sequence_AndFork(ISerializationContext context, AndFork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns AndJoin
	 *     PathBodyNode returns AndJoin
	 *     ReferencedEnd returns AndJoin
	 *     AndJoin returns AndJoin
	 *     ReferencedBoundElement returns AndJoin
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName)
	 */
	protected void sequence_AndJoin(ISerializationContext context, AndJoin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.AND_JOIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.AND_JOIN__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.AND_JOIN__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.AND_JOIN__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndJoinAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAndJoinAccess().getLongNameLongNameParserRuleCall_2_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ArtificialRule
	 *     ArtificialRule returns ArtificialRule
	 *
	 * Constraint:
	 *     longName=STRING
	 */
	protected void sequence_ArtificialRule(ISerializationContext context, ArtificialRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.ARTIFICIAL_RULE__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.ARTIFICIAL_RULE__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArtificialRuleAccess().getLongNameSTRINGTerminalRuleCall_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoundOption returns BoundElement
	 *     BoundElement returns BoundElement
	 *
	 * Constraint:
	 *     elem=[ReferencedBoundElement|QualifiedName]
	 */
	protected void sequence_BoundElement(ISerializationContext context, BoundElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.BOUND_ELEMENT__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.BOUND_ELEMENT__ELEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundElementAccess().getElemReferencedBoundElementQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(TurnPackage.Literals.BOUND_ELEMENT__ELEM, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns ComponentBinding
	 *     ComponentBinding returns ComponentBinding
	 *
	 * Constraint:
	 *     (componentIn=[ComponentRef|QualifiedName] componentOut=[ComponentRef|QualifiedName])
	 */
	protected void sequence_ComponentBinding(ISerializationContext context, ComponentBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_IN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_IN));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentBindingAccess().getComponentInComponentRefQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_IN, false));
		feeder.accept(grammarAccess.getComponentBindingAccess().getComponentOutComponentRefQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(TurnPackage.Literals.COMPONENT_BINDING__COMPONENT_OUT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ComponentRef
	 *     ComponentRef returns ComponentRef
	 *     ReferencedBoundElement returns ComponentRef
	 *
	 * Constraint:
	 *     (kind=COMPONENTKIND? name=QualifiedName longName=LongName (element=BoundOption elements+=BoundOption*)?)
	 */
	protected void sequence_ComponentRef(ISerializationContext context, ComponentRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concern returns Concern
	 *     URNmodelElement returns Concern
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName condition=Condition? element=[URNmodelElement|QualifiedName] elements+=[URNmodelElement|QualifiedName]*)
	 */
	protected void sequence_Concern(ISerializationContext context, Concern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConcreteCondition returns ConcreteCondition
	 *
	 * Constraint:
	 *     (label=STRING description=STRING)
	 */
	protected void sequence_ConcreteCondition(ISerializationContext context, ConcreteCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__LABEL));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_CONDITION__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcreteConditionAccess().getLabelSTRINGTerminalRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getConcreteConditionAccess().getDescriptionSTRINGTerminalRuleCall_1_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConcreteStrategy returns ConcreteStrategy
	 *
	 * Constraint:
	 *     author=STRING
	 */
	protected void sequence_ConcreteStrategy(ISerializationContext context, ConcreteStrategy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_STRATEGY__AUTHOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_STRATEGY__AUTHOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcreteStrategyAccess().getAuthorSTRINGTerminalRuleCall_1_0(), semanticObject.getAuthor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConcreteURNspec returns ConcreteURNspec
	 *
	 * Constraint:
	 *     (
	 *         description=STRING 
	 *         author=STRING 
	 *         created=STRING 
	 *         modified=STRING 
	 *         specVersion=STRING 
	 *         urnVersion=STRING
	 *     )
	 */
	protected void sequence_ConcreteURNspec(ISerializationContext context, ConcreteURNspec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__DESCRIPTION));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__AUTHOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__AUTHOR));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__CREATED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__CREATED));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__MODIFIED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__MODIFIED));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__SPEC_VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__SPEC_VERSION));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__URN_VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONCRETE_UR_NSPEC__URN_VERSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getAuthorSTRINGTerminalRuleCall_4_0(), semanticObject.getAuthor());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getCreatedSTRINGTerminalRuleCall_6_0(), semanticObject.getCreated());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getModifiedSTRINGTerminalRuleCall_8_0(), semanticObject.getModified());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getSpecVersionSTRINGTerminalRuleCall_10_0(), semanticObject.getSpecVersion());
		feeder.accept(grammarAccess.getConcreteURNspecAccess().getUrnVersionSTRINGTerminalRuleCall_12_0(), semanticObject.getUrnVersion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (expression=Text info=ConcreteCondition?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathBodyNode returns Connect
	 *     Connect returns Connect
	 *     ReferencedBoundElement returns Connect
	 *
	 * Constraint:
	 *     connectsTo=[ConnectElement|QualifiedName]
	 */
	protected void sequence_Connect(ISerializationContext context, Connect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.CONNECT__CONNECTS_TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.CONNECT__CONNECTS_TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectAccess().getConnectsToConnectElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(TurnPackage.Literals.CONNECT__CONNECTS_TO, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContributionChange returns ContributionChange
	 *
	 * Constraint:
	 *     (contribution=[Contribution|QualifiedName] (newContribution=ContributionType | newQuantitativeContribution=QuantitativeValue))
	 */
	protected void sequence_ContributionChange(ISerializationContext context, ContributionChange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ContributionContextGroup
	 *     ContributionContextGroup returns ContributionContextGroup
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName contrib=[ContributionContext|ID] contribs+=[ContributionContext|ID]*)
	 */
	protected void sequence_ContributionContextGroup(ISerializationContext context, ContributionContextGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns ContributionContext
	 *     ContributionContext returns ContributionContext
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         changes+=ContributionChange* 
	 *         (includedContext=[ContributionContext|ID] includedContexts+=[ContributionContext|ID]*)?
	 *     )
	 */
	protected void sequence_ContributionContext(ISerializationContext context, ContributionContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Contribution
	 *     ElementLink returns Contribution
	 *     Contribution returns Contribution
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName longName=LongName)? 
	 *         dest=[IntentionalElement|QualifiedName] 
	 *         correlation?='correlated'? 
	 *         (contribution=ContributionType | quantitativeContribution=QuantitativeValue)
	 *     )
	 */
	protected void sequence_Contribution(ISerializationContext context, Contribution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Decomposition
	 *     ElementLink returns Decomposition
	 *     Decomposition returns Decomposition
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? decompositionType=DecompositionType dest=[IntentionalElement|QualifiedName])
	 */
	protected void sequence_Decomposition(ISerializationContext context, Decomposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Dependency
	 *     ElementLink returns Dependency
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? dest=[IntentionalElement|QualifiedName])
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrBody returns OrBody
	 *     ElseOrForkBody returns OrBody
	 *
	 * Constraint:
	 *     (regularBody+=RegularOrFork+ elseBody=PathBody?)
	 */
	protected void sequence_ElseOrForkBody_OrForkBody(ISerializationContext context, OrBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EndPoint returns EndPoint
	 *     ReferencedBoundElement returns EndPoint
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName condition=Condition) | condition=Condition)?
	 */
	protected void sequence_EndPoint(ISerializationContext context, EndPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegularEnd returns EndpointWithConnect
	 *     EndpointWithConnect returns EndpointWithConnect
	 *     ReferencedBoundElement returns EndpointWithConnect
	 *
	 * Constraint:
	 *     (regularEnd=EndPoint connect=Connect?)
	 */
	protected void sequence_EndpointWithConnect(ISerializationContext context, EndpointWithConnect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns EvaluationStrategy
	 *     EvaluationStrategy returns EvaluationStrategy
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         info=ConcreteStrategy? 
	 *         evaluations+=Evaluation* 
	 *         (includedStrategy=[EvaluationStrategy|ID] includedStrategies+=[EvaluationStrategy|ID]*)?
	 *     )
	 */
	protected void sequence_EvaluationStrategy(ISerializationContext context, EvaluationStrategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns Evaluation
	 *
	 * Constraint:
	 *     (
	 *         intElement=[IntentionalElement|QualifiedName] 
	 *         exceeds?='exceeding'? 
	 *         (qualitativeEvaluation=QualitativeLabel | evaluation=QuantitativeValue | (indicatorEval=IndicatorEvaluation conversion=[IndicatorConversion|ID]))
	 *     )
	 */
	protected void sequence_Evaluation(ISerializationContext context, Evaluation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FailureLabel returns FailureLabel
	 *
	 * Constraint:
	 *     failure=STRING
	 */
	protected void sequence_FailureLabel(ISerializationContext context, FailureLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.FAILURE_LABEL__FAILURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.FAILURE_LABEL__FAILURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFailureLabelAccess().getFailureSTRINGTerminalRuleCall_1_0(), semanticObject.getFailure());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns FailurePoint
	 *     PathBodyNode returns FailurePoint
	 *     ReferencedEnd returns FailurePoint
	 *     FailurePoint returns FailurePoint
	 *     ReferencedBoundElement returns FailurePoint
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName longName=LongName) | 
	 *         ((name=QualifiedName longName=LongName) ((condition=Condition failLabel=FailureLabel) | (failLabel=FailureLabel condition=Condition)))
	 *     )?
	 */
	protected void sequence_FailurePoint(ISerializationContext context, FailurePoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns InBinding
	 *     InBinding returns InBinding
	 *
	 * Constraint:
	 *     (mapStart=[StartPoint|QualifiedName] index=PositiveInteger)
	 */
	protected void sequence_InBinding(ISerializationContext context, InBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.IN_BINDING__MAP_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.IN_BINDING__MAP_START));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.IN_BINDING__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.IN_BINDING__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInBindingAccess().getMapStartStartPointQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(TurnPackage.Literals.IN_BINDING__MAP_START, false));
		feeder.accept(grammarAccess.getInBindingAccess().getIndexPositiveIntegerParserRuleCall_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IndicatorEvaluation returns IndicatorEvaluation
	 *
	 * Constraint:
	 *     (realWorldLabel=STRING | realWorldValue=INT)
	 */
	protected void sequence_IndicatorEvaluation(ISerializationContext context, IndicatorEvaluation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns IntentionalElement
	 *     IntentionalElement returns IntentionalElement
	 *
	 * Constraint:
	 *     (
	 *         type=IntentionalElementType 
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         (importance=ImportanceType | importanceQuantitative=QuantitativeValue)? 
	 *         unit=STRING? 
	 *         linksSrc+=ElementLink*
	 *     )
	 */
	protected void sequence_IntentionalElement(ISerializationContext context, IntentionalElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns LinearConversion
	 *     IndicatorConversion returns LinearConversion
	 *     LinearConversion returns LinearConversion
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         unit=STRING 
	 *         targetValue=INT 
	 *         thresholdValue=INT 
	 *         worstValue=INT
	 *     )
	 */
	protected void sequence_LinearConversion(ISerializationContext context, LinearConversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__LONG_NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__UNIT));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__TARGET_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__TARGET_VALUE));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__THRESHOLD_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__THRESHOLD_VALUE));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__WORST_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LINEAR_CONVERSION__WORST_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinearConversionAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLinearConversionAccess().getLongNameLongNameParserRuleCall_2_0(), semanticObject.getLongName());
		feeder.accept(grammarAccess.getLinearConversionAccess().getUnitSTRINGTerminalRuleCall_5_0(), semanticObject.getUnit());
		feeder.accept(grammarAccess.getLinearConversionAccess().getTargetValueINTTerminalRuleCall_7_0(), semanticObject.getTargetValue());
		feeder.accept(grammarAccess.getLinearConversionAccess().getThresholdValueINTTerminalRuleCall_9_0(), semanticObject.getThresholdValue());
		feeder.accept(grammarAccess.getLinearConversionAccess().getWorstValueINTTerminalRuleCall_11_0(), semanticObject.getWorstValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoundOption returns LongBoundElement
	 *     LongBoundElement returns LongBoundElement
	 *
	 * Constraint:
	 *     (from=QualifiedName to=QualifiedName)
	 */
	protected void sequence_LongBoundElement(ISerializationContext context, LongBoundElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__FROM));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.LONG_BOUND_ELEMENT__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLongBoundElementAccess().getFromQualifiedNameParserRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getLongBoundElementAccess().getToQualifiedNameParserRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LongName returns LongName
	 *
	 * Constraint:
	 *     (longname=ID | longname=STRING)?
	 */
	protected void sequence_LongName(ISerializationContext context, LongName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metadata returns Metadata
	 *
	 * Constraint:
	 *     (elem=[URNmodelElement|QualifiedName]? name=ID value=Text)
	 */
	protected void sequence_Metadata(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrForkBody returns OrBody
	 *
	 * Constraint:
	 *     regularBody+=RegularOrFork+
	 */
	protected void sequence_OrForkBody(ISerializationContext context, OrBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns OrFork
	 *     RegularEnd returns OrFork
	 *     OrFork returns OrFork
	 *     ReferencedBoundElement returns OrFork
	 *
	 * Constraint:
	 *     ((((name=QualifiedName longName=LongName)? body=OrBody) | condition=Condition) connectingOrBody=PathBody?)
	 */
	protected void sequence_OrFork(ISerializationContext context, OrFork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns OrJoin
	 *     PathBodyNode returns OrJoin
	 *     ReferencedEnd returns OrJoin
	 *     OrJoin returns OrJoin
	 *     ReferencedBoundElement returns OrJoin
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName)
	 */
	protected void sequence_OrJoin(ISerializationContext context, OrJoin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OR_JOIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OR_JOIN__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OR_JOIN__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OR_JOIN__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrJoinAccess().getNameQualifiedNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOrJoinAccess().getLongNameLongNameParserRuleCall_3_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns OutBinding
	 *     OutBinding returns OutBinding
	 *
	 * Constraint:
	 *     (mapEnd=[EndPoint|QualifiedName] index=PositiveInteger)
	 */
	protected void sequence_OutBinding(ISerializationContext context, OutBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OUT_BINDING__MAP_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OUT_BINDING__MAP_END));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.OUT_BINDING__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.OUT_BINDING__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutBindingAccess().getMapEndEndPointQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(TurnPackage.Literals.OUT_BINDING__MAP_END, false));
		feeder.accept(grammarAccess.getOutBindingAccess().getIndexPositiveIntegerParserRuleCall_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathBodyNodes returns PathBodyNodes
	 *
	 * Constraint:
	 *     pathNodes+=PathBodyNode*
	 */
	protected void sequence_PathBodyNodes(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathWithReferencedEnd returns PathBodyNodes
	 *
	 * Constraint:
	 *     (pathNodes+=PathBodyNode* (referencedStub=[Stub|QualifiedName] index=PositiveInteger)? referencedEnd=[ReferencedEnd|ID]?)
	 */
	protected void sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathBody returns PathBodyNodes
	 *     PathWithRegularEnd returns PathBodyNodes
	 *
	 * Constraint:
	 *     (pathNodes+=PathBodyNode* (referencedStub=[Stub|QualifiedName] index=PositiveInteger)? referencedEnd=[ReferencedEnd|ID]? pathEnd=RegularEnd?)
	 */
	protected void sequence_PathBodyNodes_PathWithReferencedEnd_PathWithReferencedStub_PathWithRegularEnd(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathWithReferencedStub returns PathBodyNodes
	 *
	 * Constraint:
	 *     (pathNodes+=PathBodyNode* (referencedStub=[Stub|QualifiedName] index=PositiveInteger)?)
	 */
	protected void sequence_PathBodyNodes_PathWithReferencedStub(ISerializationContext context, PathBodyNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path returns Path
	 *
	 * Constraint:
	 *     (startPoint=StartPoint pathBody=PathBody)
	 */
	protected void sequence_Path(ISerializationContext context, Path semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.PATH__START_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.PATH__START_POINT));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.PATH__PATH_BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.PATH__PATH_BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathAccess().getStartPointStartPointParserRuleCall_0_0(), semanticObject.getStartPoint());
		feeder.accept(grammarAccess.getPathAccess().getPathBodyPathBodyParserRuleCall_1_0(), semanticObject.getPathBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PluginBinding returns PluginBinding
	 *
	 * Constraint:
	 *     (condition=Condition? replication=PositiveInteger? map=[UCMmap|ID] (binding=Binding bindings+=Binding*)?)
	 */
	protected void sequence_PluginBinding(ISerializationContext context, PluginBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualToQMapping returns QualToQMapping
	 *
	 * Constraint:
	 *     (exceeds?='exceeding'? realWorldLabel=STRING (qualitativeEvaluation=QualitativeLabel | evaluation=QuantitativeValue))
	 */
	protected void sequence_QualToQMapping(ISerializationContext context, QualToQMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns QualToQMappings
	 *     IndicatorConversion returns QualToQMappings
	 *     QualToQMappings returns QualToQMappings
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName unit=STRING mappings+=QualToQMapping+)
	 */
	protected void sequence_QualToQMappings(ISerializationContext context, QualToQMappings semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegularOrFork returns RegularOrFork
	 *
	 * Constraint:
	 *     (condition=Condition pathBody=PathBody)
	 */
	protected void sequence_RegularOrFork(ISerializationContext context, RegularOrFork semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__CONDITION));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__PATH_BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.REGULAR_OR_FORK__PATH_BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegularOrForkAccess().getConditionConditionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getRegularOrForkAccess().getPathBodyPathBodyParserRuleCall_1_0(), semanticObject.getPathBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns RespRef
	 *     PathBodyNode returns RespRef
	 *     ReferencedEnd returns RespRef
	 *     RespRef returns RespRef
	 *     ReferencedBoundElement returns RespRef
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName)
	 */
	protected void sequence_RespRef(ISerializationContext context, RespRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.RESP_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.RESP_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.RESP_REF__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.RESP_REF__LONG_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRespRefAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRespRefAccess().getLongNameLongNameParserRuleCall_2_0(), semanticObject.getLongName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns StartPoint
	 *     StartPoint returns StartPoint
	 *     ConnectElement returns StartPoint
	 *     ReferencedBoundElement returns StartPoint
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName longName=LongName precondition=Condition) | 
	 *         precondition=Condition | 
	 *         (failKind=FailureKind name=QualifiedName longName=LongName catches=STRING?)
	 *     )?
	 */
	protected void sequence_StartPoint(ISerializationContext context, StartPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns StrategiesGroup
	 *     StrategiesGroup returns StrategiesGroup
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName evalStrategy=[EvaluationStrategy|ID] evalStrategies+=[EvaluationStrategy|ID]*)
	 */
	protected void sequence_StrategiesGroup(ISerializationContext context, StrategiesGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StubDeclaration returns StubDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName longName=LongName params=StubParameters)
	 */
	protected void sequence_StubDeclaration(ISerializationContext context, StubDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.STUB_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.STUB_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.STUB_DECLARATION__LONG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.STUB_DECLARATION__LONG_NAME));
			if (transientValues.isValueTransient(semanticObject, TurnPackage.Literals.STUB_DECLARATION__PARAMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TurnPackage.Literals.STUB_DECLARATION__PARAMS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStubDeclarationAccess().getNameQualifiedNameParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStubDeclarationAccess().getLongNameLongNameParserRuleCall_1_0(), semanticObject.getLongName());
		feeder.accept(grammarAccess.getStubDeclarationAccess().getParamsStubParametersParserRuleCall_3_0(), semanticObject.getParams());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StubOutPath returns StubOutPath
	 *
	 * Constraint:
	 *     (index=PositiveInteger threshold=PositiveInteger? path=PathBody)
	 */
	protected void sequence_StubOutPath(ISerializationContext context, StubOutPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StubParameters returns StubParameters
	 *
	 * Constraint:
	 *     plugin+=PluginBinding*
	 */
	protected void sequence_StubParameters(ISerializationContext context, StubParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Stub
	 *     RegularEnd returns Stub
	 *     ReferencedEnd returns Stub
	 *     Stub returns Stub
	 *     ReferencedBoundElement returns Stub
	 *
	 * Constraint:
	 *     (
	 *         stubType=StubType? 
	 *         index=PositiveInteger? 
	 *         (((name=QualifiedName longName=LongName)? params=StubParameters) | stubRef=[StubDeclaration|QualifiedName]) 
	 *         outPaths+=StubOutPath* 
	 *         connectingStubBody=PathBody?
	 *     )
	 */
	protected void sequence_Stub(ISerializationContext context, Stub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Text returns Text
	 *
	 * Constraint:
	 *     content+=TextContent+
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns Timer
	 *     PathBodyNode returns Timer
	 *     Timer returns Timer
	 *     ConnectElement returns Timer
	 *     ReferencedBoundElement returns Timer
	 *
	 * Constraint:
	 *     (kind=WAITKIND? (name=QualifiedName longName=LongName)? timeoutCondition=Condition? timeoutPath=PathBody? condition=Condition?)
	 */
	protected void sequence_Timer(ISerializationContext context, Timer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns UCMmap
	 *     UCMmap returns UCMmap
	 *
	 * Constraint:
	 *     (
	 *         singleton?='singleton'? 
	 *         name=QualifiedName 
	 *         longName=LongName 
	 *         stubs+=StubDeclaration* 
	 *         paths+=Path* 
	 *         components+=ComponentRef*
	 *     )
	 */
	protected void sequence_UCMmap(ISerializationContext context, UCMmap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNlink returns URNlink
	 *     URNmodelElement returns URNlink
	 *
	 * Constraint:
	 *     ((name=QualifiedName longName=LongName)? type=Text? fromElem=[URNmodelElement|QualifiedName] toElem=[URNmodelElement|QualifiedName])
	 */
	protected void sequence_URNlink(ISerializationContext context, URNlink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNspec returns URNspec
	 *
	 * Constraint:
	 *     (
	 *         (name=QualifiedName info=ConcreteURNspec?) | 
	 *         actors+=Actor | 
	 *         showAsMeansEnd?='showAsMeansEnd' | 
	 *         stratGroups+=StrategiesGroup | 
	 *         strategies+=EvaluationStrategy | 
	 *         indConversions+=IndicatorConversion | 
	 *         contribContextGroups+=ContributionContextGroup | 
	 *         contribContexts+=ContributionContext | 
	 *         ucmMaps+=UCMmap | 
	 *         concerns+=Concern | 
	 *         urnlinks+=URNlink | 
	 *         metadata+=Metadata
	 *     )+
	 */
	protected void sequence_URNspec(ISerializationContext context, URNspec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URNmodelElement returns WaitingPlace
	 *     PathBodyNode returns WaitingPlace
	 *     WaitingPlace returns WaitingPlace
	 *     ConnectElement returns WaitingPlace
	 *     ReferencedBoundElement returns WaitingPlace
	 *
	 * Constraint:
	 *     (kind=WAITKIND? (name=QualifiedName longName=LongName)? condition=Condition?)
	 */
	protected void sequence_WaitingPlace(ISerializationContext context, WaitingPlace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
