/**
 * generated by Xtext 2.10.0
 */
package org.xtext.project.turn.validation;

import com.google.common.base.Objects;
import java.util.List;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.xtext.project.turn.turn.Actor;
import org.xtext.project.turn.turn.AndFork;
import org.xtext.project.turn.turn.Concern;
import org.xtext.project.turn.turn.Contribution;
import org.xtext.project.turn.turn.ContributionContext;
import org.xtext.project.turn.turn.ContributionContextGroup;
import org.xtext.project.turn.turn.Decomposition;
import org.xtext.project.turn.turn.Dependency;
import org.xtext.project.turn.turn.EvaluationStrategy;
import org.xtext.project.turn.turn.IntentionalElement;
import org.xtext.project.turn.turn.LinearConversion;
import org.xtext.project.turn.turn.OrFork;
import org.xtext.project.turn.turn.PathBodyNodes;
import org.xtext.project.turn.turn.QualToQMappings;
import org.xtext.project.turn.turn.StrategiesGroup;
import org.xtext.project.turn.turn.Stub;
import org.xtext.project.turn.turn.TurnPackage;
import org.xtext.project.turn.turn.URNspec;
import org.xtext.project.turn.validation.AbstractTurnValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class TurnValidator extends AbstractTurnValidator {
  @Check
  public void checkAndForkHasAtleastTwoPaths(final AndFork andFork) {
    int _size = andFork.getPathbody().size();
    boolean _lessThan = (_size < 2);
    if (_lessThan) {
      this.error("And Fork must have at least two path bodies", TurnPackage.Literals.AND_FORK__PATHBODY);
    }
  }
  
  @Check
  public void checkConcernHasUniqueName(final Concern obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends Concern> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final Concern concern : _allContentsOfType) {
      {
        if ((((!concern.getName().isEmpty()) && Objects.equal(concern.getName(), obj.getName())) && (!Objects.equal(concern, obj)))) {
          this.error("Concern name must be unique", TurnPackage.Literals.CONCERN__NAME);
        }
        if ((((!concern.getLongName().getLongname().isEmpty()) && concern.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(concern, obj)))) {
          this.error("Concern longname must be unique", TurnPackage.Literals.CONCERN__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkActorHasUniqueName(final Actor obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends Actor> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final Actor actor : _allContentsOfType) {
      {
        if ((((!actor.getName().isEmpty()) && Objects.equal(actor.getName(), obj.getName())) && (!Objects.equal(actor, obj)))) {
          this.error("Actor name must be unique", TurnPackage.Literals.ACTOR__NAME);
        }
        if ((((!actor.getLongName().getLongname().isEmpty()) && actor.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(actor, obj)))) {
          this.error("Actor longname must be unique", TurnPackage.Literals.ACTOR__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkIntElementHasUniqueName(final IntentionalElement obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends IntentionalElement> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final IntentionalElement intElem : _allContentsOfType) {
      {
        if ((((!intElem.getName().isEmpty()) && Objects.equal(intElem.getName(), obj.getName())) && (!Objects.equal(intElem, obj)))) {
          this.error("IntentionalElement name must be unique", TurnPackage.Literals.INTENTIONAL_ELEMENT__NAME);
        }
        if ((((!intElem.getLongName().getLongname().isEmpty()) && intElem.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(intElem, obj)))) {
          this.error("IntentionalElement longname must be unique", TurnPackage.Literals.INTENTIONAL_ELEMENT__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkContributionHasUniqueName(final Contribution obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends Contribution> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final Contribution cont : _allContentsOfType) {
      {
        if ((((!cont.getName().isEmpty()) && Objects.equal(cont.getName(), obj.getName())) && (!Objects.equal(cont, obj)))) {
          this.error("Contribution name must be unique", TurnPackage.Literals.CONTRIBUTION__NAME);
        }
        if ((((!cont.getLongName().getLongname().isEmpty()) && cont.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(cont, obj)))) {
          this.error("Contribution longname must be unique", TurnPackage.Literals.CONTRIBUTION__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkDecompositionHasUniqueName(final Decomposition obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends Decomposition> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final Decomposition decomp : _allContentsOfType) {
      {
        if ((((!decomp.getName().isEmpty()) && Objects.equal(decomp.getName(), obj.getName())) && (!Objects.equal(decomp, obj)))) {
          this.error("Decomposition name must be unique", TurnPackage.Literals.DECOMPOSITION__NAME);
        }
        if ((((!decomp.getLongName().getLongname().isEmpty()) && decomp.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(decomp, obj)))) {
          this.error("Decomposition longname must be unique", TurnPackage.Literals.DECOMPOSITION__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkDependencyHasUniqueName(final Dependency obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends Dependency> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final Dependency dep : _allContentsOfType) {
      {
        if ((((!dep.getName().isEmpty()) && Objects.equal(dep.getName(), obj.getName())) && (!Objects.equal(dep, obj)))) {
          this.error("Dependency name must be unique", TurnPackage.Literals.DEPENDENCY__NAME);
        }
        if ((((!dep.getLongName().getLongname().isEmpty()) && dep.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(dep, obj)))) {
          this.error("Dependency longname must be unique", TurnPackage.Literals.DEPENDENCY__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkStrategiesGroupHasUniqueName(final StrategiesGroup obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends StrategiesGroup> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final StrategiesGroup sg : _allContentsOfType) {
      {
        if ((((!sg.getName().isEmpty()) && Objects.equal(sg.getName(), obj.getName())) && (!Objects.equal(sg, obj)))) {
          this.error("StrategiesGroup name must be unique", TurnPackage.Literals.STRATEGIES_GROUP__NAME);
        }
        if ((((!sg.getLongName().getLongname().isEmpty()) && sg.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(sg, obj)))) {
          this.error("StrategiesGroup longname must be unique", TurnPackage.Literals.STRATEGIES_GROUP__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkStrategyHasUniqueName(final EvaluationStrategy obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends EvaluationStrategy> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final EvaluationStrategy sg : _allContentsOfType) {
      {
        if ((((!sg.getName().isEmpty()) && Objects.equal(sg.getName(), obj.getName())) && (!Objects.equal(sg, obj)))) {
          this.error("EvaluationStrategy name must be unique", TurnPackage.Literals.EVALUATION_STRATEGY__NAME);
        }
        if ((((!sg.getLongName().getLongname().isEmpty()) && sg.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(sg, obj)))) {
          this.error("EvaluationStrategy longname must be unique", TurnPackage.Literals.EVALUATION_STRATEGY__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkContribContextGroupHasUniqueName(final ContributionContextGroup obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends ContributionContextGroup> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final ContributionContextGroup sg : _allContentsOfType) {
      {
        if ((((!sg.getName().isEmpty()) && Objects.equal(sg.getName(), obj.getName())) && (!Objects.equal(sg, obj)))) {
          this.error("ContributionContextGroup name must be unique", TurnPackage.Literals.CONTRIBUTION_CONTEXT_GROUP__NAME);
        }
        if ((((!sg.getLongName().getLongname().isEmpty()) && sg.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(sg, obj)))) {
          this.error("ContributionContextGroup longname must be unique", TurnPackage.Literals.CONTRIBUTION_CONTEXT_GROUP__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkContribContextHasUniqueName(final ContributionContext obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends ContributionContext> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final ContributionContext cc : _allContentsOfType) {
      {
        if ((((!cc.getName().isEmpty()) && Objects.equal(cc.getName(), obj.getName())) && (!Objects.equal(cc, obj)))) {
          this.error("ContributionContextGroup name must be unique", TurnPackage.Literals.CONTRIBUTION_CONTEXT__NAME);
        }
        if ((((!cc.getLongName().getLongname().isEmpty()) && cc.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(cc, obj)))) {
          this.error("ContributionContextGroup longname must be unique", TurnPackage.Literals.CONTRIBUTION_CONTEXT__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkLinearConversionHasUniqueName(final LinearConversion obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends LinearConversion> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final LinearConversion lc : _allContentsOfType) {
      {
        if ((((!lc.getName().isEmpty()) && Objects.equal(lc.getName(), obj.getName())) && (!Objects.equal(lc, obj)))) {
          this.error("LinearConversion name must be unique", TurnPackage.Literals.LINEAR_CONVERSION__NAME);
        }
        if ((((!lc.getLongName().getLongname().isEmpty()) && lc.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(lc, obj)))) {
          this.error("LinearConversion longname must be unique", TurnPackage.Literals.LINEAR_CONVERSION__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkQualToQMappingsHasUniqueName(final QualToQMappings obj) {
    final URNspec spec = EcoreUtil2.<URNspec>getContainerOfType(obj, URNspec.class);
    List<? extends QualToQMappings> _allContentsOfType = EcoreUtil2.getAllContentsOfType(spec, obj.getClass());
    for (final QualToQMappings mc : _allContentsOfType) {
      {
        if ((((!mc.getName().isEmpty()) && Objects.equal(mc.getName(), obj.getName())) && (!Objects.equal(mc, obj)))) {
          this.error("QualToQMappings name must be unique", TurnPackage.Literals.QUAL_TO_QMAPPINGS__NAME);
        }
        if ((((!mc.getLongName().getLongname().isEmpty()) && mc.getLongName().getLongname().equals(obj.getLongName().getLongname())) && (!Objects.equal(mc, obj)))) {
          this.error("QualToQMappings longname must be unique", TurnPackage.Literals.QUAL_TO_QMAPPINGS__LONG_NAME);
        }
      }
    }
  }
  
  @Check
  public void testOrder(final PathBodyNodes mc) {
    if (((mc.getReferencedStub() != null) && (mc.getPathEnd() != null))) {
      this.error("Wrong order of reference", TurnPackage.Literals.PATH_BODY__REFERENCED_STUB);
    }
    if (((mc.getReferencedEnd() != null) && (mc.getPathEnd() != null))) {
      this.error("Wrong order of reference", TurnPackage.Literals.PATH_BODY__REFERENCED_END);
    }
  }
  
  @Check
  public void testOrder2(final PathBodyNodes mc) {
    final OrFork of = EcoreUtil2.<OrFork>getContainerOfType(mc, OrFork.class);
    final AndFork af = EcoreUtil2.<AndFork>getContainerOfType(mc, AndFork.class);
    final Stub stub = EcoreUtil2.<Stub>getContainerOfType(mc, Stub.class);
    if (((((mc.getReferencedStub() == null) && (mc.getPathEnd() == null)) && (mc.getPathNodes().size() == 0)) && (mc.getReferencedEnd() == null))) {
      if ((((of == null) && (af == null)) && (stub == null))) {
        this.error("Wrong order of reference", TurnPackage.Literals.PATH_BODY_NODES__PATH_NODES);
      }
    }
  }
}
